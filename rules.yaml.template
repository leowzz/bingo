# ============================================================================
# BinGo 规则配置文件模板
# ============================================================================
# 使用说明：
# 1. 复制此文件为 rules.yaml: cp rules.yaml.template rules.yaml
# 2. 根据业务需求添加或修改规则
# 3. 规则字段说明：
#    - id: 规则唯一标识（必填）
#    - name: 规则名称，用于日志显示（可选）
#    - database: 监控的数据库名（必填）
#    - table: 监控的表名（必填）
#    - events: 监听的事件类型，可选: INSERT, UPDATE, DELETE（必填）
#    - filter: CEL 表达式过滤条件，留空或 "true" 表示匹配所有（可选）
#    - actions: 匹配后执行的动作列表（必填）
#
# Redis 连接配置：
#   可以在 rules.yaml 中定义多个 Redis 连接，规则中的 Redis 动作可以指定使用哪个连接
#   也可以使用 "system" 来使用系统 Redis（在 config.yaml 中配置的 system_redis）
#
# 模板变量说明：
#   在动作配置中可以使用模板变量，如 {{ .ID }}, {{ .Table }}, {{ .Action }} 等
#   - {{ .ID }}: 主键字段值（从 NewRow 或 OldRow 中提取）
#   - {{ .Table }}: 表名
#   - {{ .Action }}: 操作类型（INSERT/UPDATE/DELETE）
#   - {{ .NewRow }}: 新行数据（INSERT/UPDATE 时可用）
#   - {{ .OldRow }}: 旧行数据（UPDATE/DELETE 时可用）
#   - {{ .FieldName }}: 任意字段名（首字母大写，如 {{ .Email }}, {{ .Status }}）
# ============================================================================

# Redis 连接配置（可选）
# 规则中的 Redis 动作可以通过 redis_conn 字段指定使用哪个连接
# 特殊名称 "system" 表示使用系统 Redis（在 config.yaml 中配置的 system_redis）
redis_connections:
  - name: "cache"                    # 连接名称
    addr: "localhost:6379"          # Redis 服务器地址
    password: ""                    # Redis 密码（如果未设置密码则留空）
    db: 1                           # Redis 数据库编号
  - name: "session"                 # 另一个 Redis 连接示例
    addr: "localhost:6379"
    password: ""
    db: 2

rules:
  # 示例 1: 用户缓存失效
  # 当 users 表发生 UPDATE 或 DELETE 操作时，自动删除对应的 Redis 缓存
  - id: "user_cache_invalidate"
    name: "用户缓存失效"
    database: "test_db"              # 监控的数据库名（必填）
    table: "users"                    # 监控的表名（必填）
    events: ["UPDATE", "DELETE"]      # 监听更新和删除事件
    filter: "true"                    # 匹配所有更新和删除操作（可改为 CEL 表达式进行条件过滤）
    actions:
      - type: "redis"                 # Redis 动作
        cmd: "DEL"                     # 删除命令
        key: "cache:user:{{ .ID }}"   # 使用模板变量 {{ .ID }} 动态生成 key
        redis_conn: "cache"           # 指定使用名为 "cache" 的 Redis 连接
                                      # 可选值：
                                      #   - "cache": 使用规则中定义的 "cache" 连接
                                      #   - "system": 使用系统 Redis（config.yaml 中的 system_redis）
                                      #   - 不指定或 "default": 使用默认连接（优先 default，其次 system，最后第一个可用连接）
      - type: "log"                    # 日志动作
        level: "info"
        message: "用户缓存已失效: user_id={{ .ID }}"

  # 示例 4: 使用系统 Redis 的规则
  # 当订单创建时，在系统 Redis 中记录统计信息
  - id: "order_statistics"
    name: "订单统计"
    database: "test_db"              # 监控的数据库名（必填）
    table: "orders"                   # 监控的表名（必填）
    events: ["INSERT"]
    filter: "true"
    actions:
      - type: "redis"
        cmd: "INCR"
        key: "stats:orders:total"
        redis_conn: "system"          # 使用系统 Redis
      - type: "log"
        level: "info"
        message: "订单统计已更新: order_id={{ .ID }}"

  # 示例 2: 订单状态变更通知
  # 当订单状态变更为 completed 时，发送 Webhook 通知
  - id: "order_status_notify"
    name: "订单状态变更通知"
    database: "test_db"              # 监控的数据库名（必填）
    table: "orders"                    # 监控的表名（必填）
    events: ["UPDATE"]                 # 仅监听更新事件
    filter: "true"                     # 可改为: "NewRow['status'] == 'completed' && OldRow['status'] != 'completed'"
    actions:
      - type: "webhook"                # Webhook 动作
        url: "https://api.example.com/order/completed"
        method: "POST"
        headers:
          Content-Type: "application/json"
        body: |                        # 请求体，支持多行 YAML 字符串
          {
            "order_id": "{{ .ID }}",
            "status": "{{ .Status }}"
          }
        timeout: 5                     # 超时时间（秒）
        retry: 3                       # 重试次数
      - type: "log"
        level: "info"
        message: "订单状态变更: order_id={{ .ID }}, status={{ .Status }}"

  # 示例 3: 发送 Kafka 消息
  # 当用户注册时，发送消息到 Kafka 主题
  - id: "user_register_kafka"
    name: "用户注册 Kafka 消息"
    database: "test_db"
    table: "users"
    events: ["INSERT"]
    filter: "true"
    actions:
      - type: "kafka"                    # Kafka 动作
        brokers:                          # Kafka broker 地址列表
          - "localhost:9092"
          - "localhost:9093"
        topic: "user-events"              # 主题名称（支持模板变量）
        partition: 0                      # 分区号，0 表示自动选择分区
        key: "user:{{ .ID }}"             # 消息键（可选，支持模板变量）
        value: |                          # 消息值（可选，支持模板变量，如果不指定则使用默认 JSON 格式）
          {
            "event_type": "user_register",
            "user_id": {{ .ID }},
            "email": "{{ .Email }}",
            "created_at": "{{ .CreatedAt }}"
          }
      - type: "log"
        level: "info"
        message: "用户注册消息已发送到 Kafka: user_id={{ .ID }}"

  # 示例 5: 订单变更发送到 Kafka（使用默认 JSON 格式）
  # 当订单发生变更时，自动发送订单数据到 Kafka
  - id: "order_change_kafka"
    name: "订单变更 Kafka 消息"
    database: "test_db"
    table: "orders"
    events: ["INSERT", "UPDATE"]
    filter: "true"
    actions:
      - type: "kafka"
        brokers:
          - "kafka1.example.com:9092"
          - "kafka2.example.com:9092"
        topic: "orders.{{ .Action | lower }}"  # 使用模板变量动态生成主题名
        # 不指定 value，将使用默认的 JSON 格式（包含 NewRow 数据）
        # 不指定 key，消息将没有键
      - type: "log"
        level: "debug"
        message: "订单变更消息已发送到 Kafka: order_id={{ .ID }}"

  # 示例 6: 发送 RabbitMQ 消息
  # 当订单完成时，发送消息到 RabbitMQ
  - id: "order_complete_rabbitmq"
    name: "订单完成 RabbitMQ 通知"
    database: "test_db"
    table: "orders"
    events: ["UPDATE"]
    filter: "NewRow['status'] == 'completed' && OldRow['status'] != 'completed'"
    actions:
      - type: "rabbitmq"                  # RabbitMQ 动作
        rabbitmq_url: "amqp://guest:guest@localhost:5672/"
        rabbitmq_exchange: "order_events"  # 交换机名称
        rabbitmq_routing_key: "order.completed"  # 路由键（支持模板变量）
        rabbitmq_message: |                # 消息内容（支持模板变量）
          {
            "order_id": "{{ .ID }}",
            "user_id": {{ .UserId }},
            "total_amount": {{ .TotalAmount }},
            "status": "{{ .Status }}",
            "completed_at": "{{ .UpdatedAt }}"
          }
      - type: "log"
        level: "info"
        message: "订单完成 RabbitMQ 通知已发送: order_id={{ .ID }}"

  # 示例 7: RabbitMQ 发送到队列（不经过交换机）
  # 当用户被删除时，发送消息到 RabbitMQ 队列
  - id: "user_delete_rabbitmq"
    name: "用户删除 RabbitMQ 通知"
    database: "test_db"
    table: "users"
    events: ["DELETE"]
    filter: "true"
    actions:
      - type: "rabbitmq"
        rabbitmq_url: "amqp://guest:guest@localhost:5672/"
        rabbitmq_queue: "user_deletions"  # 直接发送到队列（不经过交换机）
        rabbitmq_message: "{{ .OldRow | toJson }}"  # 使用默认 JSON 格式
      - type: "log"
        level: "info"
        message: "用户删除 RabbitMQ 通知已发送: user_id={{ .ID }}"

  # 示例 8: 组合使用多个动作类型
  # 当商品库存变更时，同时执行 Redis、Kafka 和 RabbitMQ 操作
  - id: "product_stock_change"
    name: "商品库存变更处理"
    database: "test_db"
    table: "products"
    events: ["UPDATE"]
    filter: "NewRow['stock'] != OldRow['stock']"
    actions:
      - type: "redis"                     # 更新 Redis 缓存
        cmd: "SET"
        key: "product:stock:{{ .ID }}"
        value: "{{ .Stock }}"
        redis_conn: "cache"
      - type: "kafka"                     # 发送库存变更消息到 Kafka
        brokers:
          - "localhost:9092"
        topic: "product-stock-changes"
        key: "product:{{ .ID }}"
        value: |
          {
            "product_id": {{ .ID }},
            "old_stock": {{ .OldRow.Stock }},
            "new_stock": {{ .Stock }},
            "changed_at": "{{ .Timestamp }}"
          }
      - type: "rabbitmq"                  # 发送库存变更消息到 RabbitMQ
        rabbitmq_url: "amqp://guest:guest@localhost:5672/"
        rabbitmq_exchange: "inventory"
        rabbitmq_routing_key: "stock.update"
        rabbitmq_message: |
          {
            "product_id": {{ .ID }},
            "stock": {{ .Stock }}
          }
      - type: "log"
        level: "info"
        message: "商品库存已更新: product_id={{ .ID }}, stock={{ .Stock }}"

